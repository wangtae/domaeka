# ì†Œì¼“ ê´€ë ¨ ê°œì„ ì‚¬í•­

## ê°œìš”

### í˜„ì¬ êµ¬í˜„ ìƒíƒœ
Domaeka ì¹´ì¹´ì˜¤ë´‡ ì‹œìŠ¤í…œì˜ TCP ì„œë²„-í´ë¼ì´ì–¸íŠ¸ í†µì‹ ì€ ê¸°ë³¸ì ì¸ ì•ˆì •ì„± ìš”ì†Œë“¤ì´ êµ¬í˜„ë˜ì–´ ìˆìœ¼ë‚˜, 
ìš´ì˜ í™˜ê²½ì—ì„œì˜ ë” ë†’ì€ ì•ˆì •ì„±ê³¼ ë³µì›ë ¥ì„ ìœ„í•´ ì¶”ê°€ ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.

### ê°œì„  ëª©í‘œ
- ë„¤íŠ¸ì›Œí¬ ì¥ì•  ìƒí™©ì—ì„œì˜ ë¹ ë¥¸ ê°ì§€ì™€ ë³µêµ¬
- ì—°ê²° í’ˆì§ˆ ëª¨ë‹ˆí„°ë§ ë° ìë™ ì¡°ì •
- ëŒ€ê·œëª¨ íŠ¸ë˜í”½ ì²˜ë¦¬ë¥¼ ìœ„í•œ ìµœì í™”
- ë³´ì•ˆ ê°•í™” ë° ì•…ì˜ì  ì—°ê²° ì°¨ë‹¨

## 1. ì—°ê²° ìˆ˜ì¤€ ê°œì„ ì‚¬í•­

### í˜„ì¬ êµ¬í˜„ëœ ê²ƒ âœ…
- [x] **TCP_NODELAY**: Nagle ì•Œê³ ë¦¬ì¦˜ ë¹„í™œì„±í™”ë¡œ ì§€ì—° ìµœì†Œí™”
- [x] **SO_KEEPALIVE**: 30ì´ˆ idle, 10ì´ˆ ê°„ê²©, 9íšŒ ì¬ì‹œë„
- [x] **ì†Œì¼“ ë²„í¼ í¬ê¸°**: 64KBë¡œ ì¦ê°€
- [x] **ìµœëŒ€ ë™ì‹œ ì—°ê²° ìˆ˜ ì œí•œ**: 100ê°œ
- [x] **ë©”ì‹œì§€ í¬ê¸° ì œí•œ**: 1MB

### ì¶”ê°€ ê¶Œì¥ì‚¬í•­ ğŸ“‹

#### 1.1 SO_REUSEADDR - í¬íŠ¸ ì¬ì‚¬ìš©
```python
# server.pyì— ì¶”ê°€
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
```
**íš¨ê³¼**: ì„œë²„ ì¬ì‹œì‘ ì‹œ "Address already in use" ì˜¤ë¥˜ ë°©ì§€

#### 1.2 SO_LINGER - ì—°ê²° ì¢…ë£Œ ì œì–´
```python
# ì—°ê²° ì¢…ë£Œ ì‹œ 5ì´ˆê°„ ë‚¨ì€ ë°ì´í„° ì „ì†¡ ì‹œë„
import struct
sock.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, struct.pack('ii', 1, 5))
```
**íš¨ê³¼**: ì—°ê²° ì¢…ë£Œ ì‹œ ë°ì´í„° ì†ì‹¤ ë°©ì§€

#### 1.3 TCP_USER_TIMEOUT - ì „ì†¡ íƒ€ì„ì•„ì›ƒ
```python
# Linux ì „ìš© - ë°ì´í„° ì „ì†¡ íƒ€ì„ì•„ì›ƒ ì„¤ì •
if platform.system() == "Linux":
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_USER_TIMEOUT, 60000)  # 60ì´ˆ
```
**íš¨ê³¼**: ì‘ë‹µ ì—†ëŠ” ì—°ê²°ì„ ë” ë¹ ë¥´ê²Œ ê°ì§€

## 2. ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ ê°œì„ ì‚¬í•­

### í˜„ì¬ êµ¬í˜„ëœ ê²ƒ âœ…
- [x] **ì£¼ê¸°ì  ping ì „ì†¡**: 30ì´ˆë§ˆë‹¤ í´ë¼ì´ì–¸íŠ¸ë³„ ë…ë¦½ íƒœìŠ¤í¬
- [x] **ì´ˆê¸° ping ì§€ì—°**: 1-59ì´ˆ ëœë¤ìœ¼ë¡œ ë¶€í•˜ ë¶„ì‚°
- [x] **ë©”ì‹œì§€ í TTL**: 30ì´ˆ (í´ë¼ì´ì–¸íŠ¸)

### ì¶”ê°€ ê¶Œì¥ì‚¬í•­ ğŸ“‹

#### 2.1 Ping ì‘ë‹µ íƒ€ì„ì•„ì›ƒ ê´€ë¦¬
```python
# client_handler.pyì— ì¶”ê°€
class PingTimeoutManager:
    def __init__(self, timeout=90):
        self.timeout = timeout
        self.ping_timestamps = {}  # {client_key: last_ping_time}
        self.pong_received = {}    # {client_key: last_pong_time}
    
    async def check_timeouts(self):
        """íƒ€ì„ì•„ì›ƒëœ ì—°ê²° ê°ì§€ ë° ì¢…ë£Œ"""
        current_time = time.time()
        for client_key, last_ping in list(self.ping_timestamps.items()):
            last_pong = self.pong_received.get(client_key, 0)
            if current_time - last_ping > self.timeout and last_pong < last_ping:
                logger.warning(f"[TIMEOUT] Ping ì‘ë‹µ ì—†ìŒ: {client_key}")
                await self.disconnect_client(client_key)
```

#### 2.2 ì¬ì—°ê²° ë°±ì˜¤í”„ ì „ëµ ê°•í™”
```python
# í´ë¼ì´ì–¸íŠ¸ ì¬ì—°ê²° ë¡œì§ ê°œì„ 
class ExponentialBackoff:
    def __init__(self, base_delay=2, max_delay=60, jitter_factor=0.1):
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.jitter_factor = jitter_factor
        self.attempts = 0
    
    def get_delay(self):
        # ì§€ìˆ˜ ë°±ì˜¤í”„ + ì§€í„°
        delay = min(self.base_delay * (2 ** self.attempts), self.max_delay)
        jitter = random.uniform(0, delay * self.jitter_factor)
        self.attempts += 1
        return delay + jitter
    
    def reset(self):
        self.attempts = 0
```

#### 2.3 ì—°ê²° í’ˆì§ˆ ëª¨ë‹ˆí„°ë§
```python
# ì—°ê²°ë³„ í’ˆì§ˆ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
class ConnectionQualityMonitor:
    def __init__(self):
        self.metrics = {}  # {client_key: ConnectionMetrics}
    
    class ConnectionMetrics:
        def __init__(self):
            self.rtt_samples = []  # Round Trip Time
            self.packet_loss = 0
            self.last_activity = time.time()
            self.bytes_sent = 0
            self.bytes_received = 0
            self.message_count = 0
        
        def add_rtt_sample(self, rtt):
            self.rtt_samples.append(rtt)
            if len(self.rtt_samples) > 100:
                self.rtt_samples.pop(0)
        
        @property
        def avg_rtt(self):
            return sum(self.rtt_samples) / len(self.rtt_samples) if self.rtt_samples else 0
```

## 3. ë©”ì‹œì§€ ì²˜ë¦¬ ê°œì„ ì‚¬í•­

### ì¶”ê°€ ê¶Œì¥ì‚¬í•­ ğŸ“‹

#### 3.1 ë©”ì‹œì§€ ì••ì¶•
```python
import gzip

class MessageCompressor:
    COMPRESSION_THRESHOLD = 10240  # 10KB
    
    @staticmethod
    def compress_if_needed(message: bytes) -> tuple[bytes, bool]:
        """í•„ìš”ì‹œ ë©”ì‹œì§€ ì••ì¶•"""
        if len(message) > MessageCompressor.COMPRESSION_THRESHOLD:
            compressed = gzip.compress(message)
            if len(compressed) < len(message) * 0.9:  # 10% ì´ìƒ ì••ì¶•
                return compressed, True
        return message, False
    
    @staticmethod
    def decompress(message: bytes) -> bytes:
        """ì••ì¶•ëœ ë©”ì‹œì§€ í•´ì œ"""
        return gzip.decompress(message)
```

#### 3.2 ìš°ì„ ìˆœìœ„ í
```python
import asyncio
from enum import IntEnum

class MessagePriority(IntEnum):
    CRITICAL = 0  # ping/pong, ì‹œìŠ¤í…œ ë©”ì‹œì§€
    HIGH = 1      # ëª…ë ¹ì–´ ì‘ë‹µ
    NORMAL = 2    # ì¼ë°˜ ë©”ì‹œì§€
    LOW = 3       # ë¡œê·¸, í†µê³„

class PriorityMessageQueue:
    def __init__(self):
        self.queue = asyncio.PriorityQueue()
    
    async def put(self, priority: MessagePriority, message):
        await self.queue.put((priority, time.time(), message))
    
    async def get(self):
        priority, timestamp, message = await self.queue.get()
        return message
```

#### 3.3 íšŒë¡œ ì°¨ë‹¨ê¸° íŒ¨í„´
```python
class CircuitBreaker:
    """ì—°ì† ì‹¤íŒ¨ ì‹œ ì¼ì‹œì  ì°¨ë‹¨"""
    
    def __init__(self, failure_threshold=5, recovery_timeout=60):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
    
    def record_success(self):
        self.failure_count = 0
        self.state = "CLOSED"
    
    def record_failure(self):
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.failure_threshold:
            self.state = "OPEN"
            logger.warning(f"[CIRCUIT] íšŒë¡œ ì°¨ë‹¨ê¸° OPEN - {self.failure_count}íšŒ ì—°ì† ì‹¤íŒ¨")
    
    def can_attempt(self):
        if self.state == "CLOSED":
            return True
        
        if self.state == "OPEN":
            if time.time() - self.last_failure_time > self.recovery_timeout:
                self.state = "HALF_OPEN"
                return True
        
        return self.state == "HALF_OPEN"
```

## 4. ë³´ì•ˆ ë° ì¸ì¦ ê°•í™”

### ì¶”ê°€ ê¶Œì¥ì‚¬í•­ ğŸ“‹

#### 4.1 ì—°ê²° ì†ë„ ì œí•œ
```python
from collections import defaultdict, deque

class RateLimiter:
    """IPë³„ ì—°ê²° ì†ë„ ì œí•œ"""
    
    def __init__(self, max_connections_per_minute=10):
        self.max_connections = max_connections_per_minute
        self.connection_attempts = defaultdict(deque)
    
    def is_allowed(self, ip_address: str) -> bool:
        now = time.time()
        attempts = self.connection_attempts[ip_address]
        
        # 1ë¶„ ì´ìƒ ì§€ë‚œ ì‹œë„ ì œê±°
        while attempts and attempts[0] < now - 60:
            attempts.popleft()
        
        if len(attempts) >= self.max_connections:
            return False
        
        attempts.append(now)
        return True
    
    def block_ip(self, ip_address: str, duration=3600):
        """íŠ¹ì • IP ì¼ì‹œ ì°¨ë‹¨"""
        # êµ¬í˜„ í•„ìš”
        pass
```

#### 4.2 í† í° ê¸°ë°˜ ì¬ì¸ì¦
```python
import secrets
from datetime import datetime, timedelta

class SessionManager:
    """ì„¸ì…˜ í† í° ê´€ë¦¬"""
    
    def __init__(self, token_lifetime=3600):
        self.sessions = {}  # {client_key: SessionInfo}
        self.token_lifetime = token_lifetime
    
    def create_session(self, client_key):
        token = secrets.token_urlsafe(32)
        self.sessions[client_key] = {
            'token': token,
            'created': datetime.now(),
            'last_used': datetime.now()
        }
        return token
    
    def validate_token(self, client_key, token):
        session = self.sessions.get(client_key)
        if not session:
            return False
        
        if session['token'] != token:
            return False
        
        # í† í° ë§Œë£Œ í™•ì¸
        if datetime.now() - session['created'] > timedelta(seconds=self.token_lifetime):
            del self.sessions[client_key]
            return False
        
        session['last_used'] = datetime.now()
        return True
```

## 5. ëª¨ë‹ˆí„°ë§ ë° ê´€ì°°ì„±

### ì¶”ê°€ ê¶Œì¥ì‚¬í•­ ğŸ“‹

#### 5.1 ìƒì„¸ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
```python
class ServerMetrics:
    """ì„œë²„ ì „ì²´ ë©”íŠ¸ë¦­"""
    
    def __init__(self):
        self.start_time = time.time()
        self.total_connections = 0
        self.active_connections = 0
        self.messages_sent = 0
        self.messages_received = 0
        self.bytes_sent = 0
        self.bytes_received = 0
        self.errors = defaultdict(int)
        
    def get_stats(self):
        uptime = time.time() - self.start_time
        return {
            'uptime': uptime,
            'total_connections': self.total_connections,
            'active_connections': self.active_connections,
            'message_rate': self.messages_sent / uptime if uptime > 0 else 0,
            'throughput': {
                'sent': self.bytes_sent / uptime if uptime > 0 else 0,
                'received': self.bytes_received / uptime if uptime > 0 else 0
            },
            'errors': dict(self.errors)
        }
```

#### 5.2 í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸
```python
# ë³„ë„ HTTP ì„œë²„ë¡œ í—¬ìŠ¤ì²´í¬ ì œê³µ
from aiohttp import web

class HealthCheckServer:
    def __init__(self, port=8080):
        self.port = port
        self.app = web.Application()
        self.app.router.add_get('/health', self.health_check)
        self.app.router.add_get('/metrics', self.metrics)
    
    async def health_check(self, request):
        """ê¸°ë³¸ í—¬ìŠ¤ì²´í¬"""
        health = {
            'status': 'healthy' if g.server else 'unhealthy',
            'timestamp': datetime.now().isoformat(),
            'connections': len(g.clients)
        }
        return web.json_response(health)
    
    async def metrics(self, request):
        """ìƒì„¸ ë©”íŠ¸ë¦­"""
        metrics = server_metrics.get_stats()
        return web.json_response(metrics)
    
    async def start(self):
        runner = web.AppRunner(self.app)
        await runner.setup()
        site = web.TCPSite(runner, '0.0.0.0', self.port)
        await site.start()
```

## 6. ì¥ì•  ë³µêµ¬ ì „ëµ

### ì¶”ê°€ ê¶Œì¥ì‚¬í•­ ğŸ“‹

#### 6.1 ê·¸ë ˆì´ìŠ¤í’€ ì…§ë‹¤ìš´
```python
import signal

class GracefulShutdown:
    """ìš°ì•„í•œ ì¢…ë£Œ ì²˜ë¦¬"""
    
    def __init__(self):
        self.shutdown_in_progress = False
        signal.signal(signal.SIGTERM, self._signal_handler)
        signal.signal(signal.SIGINT, self._signal_handler)
    
    def _signal_handler(self, signum, frame):
        logger.info(f"[SHUTDOWN] ì¢…ë£Œ ì‹ í˜¸ ìˆ˜ì‹ : {signum}")
        asyncio.create_task(self.shutdown())
    
    async def shutdown(self):
        if self.shutdown_in_progress:
            return
        
        self.shutdown_in_progress = True
        logger.info("[SHUTDOWN] ìš°ì•„í•œ ì¢…ë£Œ ì‹œì‘...")
        
        # 1. ìƒˆ ì—°ê²° ê±°ë¶€
        g.server.close()
        
        # 2. í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì¢…ë£Œ ì•Œë¦¼
        await self.notify_clients_shutdown()
        
        # 3. ì§„í–‰ ì¤‘ì¸ ì‘ì—… ì™„ë£Œ ëŒ€ê¸° (ìµœëŒ€ 30ì´ˆ)
        await self.wait_for_pending_tasks(timeout=30)
        
        # 4. ì—°ê²° ì¢…ë£Œ
        await self.close_all_connections()
        
        # 5. ì¢…ë£Œ ì´ë²¤íŠ¸ ì„¤ì •
        g.shutdown_event.set()
    
    async def notify_clients_shutdown(self):
        """ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì¢…ë£Œ ì•Œë¦¼"""
        shutdown_message = {
            "event": "serverShutdown",
            "data": {
                "reason": "maintenance",
                "reconnect_after": 60  # 60ì´ˆ í›„ ì¬ì—°ê²° ê¶Œì¥
            }
        }
        # êµ¬í˜„ í•„ìš”
```

#### 6.2 ì—°ê²° ë§ˆì´ê·¸ë ˆì´ì…˜
```python
class ConnectionMigration:
    """ë¬´ì¤‘ë‹¨ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ì—°ê²° ë§ˆì´ê·¸ë ˆì´ì…˜"""
    
    def __init__(self):
        self.migration_in_progress = False
        self.target_server = None
    
    async def start_migration(self, target_host, target_port):
        """ìƒˆ ì„œë²„ë¡œ ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜"""
        self.migration_in_progress = True
        self.target_server = (target_host, target_port)
        
        # ìƒˆ ì—°ê²°ì€ ìƒˆ ì„œë²„ë¡œ ì•ˆë‚´
        g.redirect_new_connections = True
        
        # ê¸°ì¡´ ì—°ê²°ì€ ìœ ì§€í•˜ë©´ì„œ ì ì§„ì ìœ¼ë¡œ ì´ë™
        await self.migrate_existing_connections()
    
    async def migrate_existing_connections(self):
        """ê¸°ì¡´ ì—°ê²° ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜"""
        for client_key in list(g.clients.keys()):
            # í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ìƒˆ ì„œë²„ ì •ë³´ ì „ì†¡
            migration_info = {
                "event": "serverMigration",
                "data": {
                    "new_host": self.target_server[0],
                    "new_port": self.target_server[1],
                    "migrate_after": 30  # 30ì´ˆ í›„ ì´ë™
                }
            }
            # êµ¬í˜„ í•„ìš”
```

## êµ¬í˜„ ìš°ì„ ìˆœìœ„ ë° ë¡œë“œë§µ

### Phase 1 (ì¦‰ì‹œ êµ¬í˜„ ê°€ëŠ¥) - 1ì£¼
1. âœ… SO_REUSEADDR ì„¤ì •
2. âœ… Ping ì‘ë‹µ íƒ€ì„ì•„ì›ƒ ê´€ë¦¬
3. âœ… ì—°ê²° ì†ë„ ì œí•œ
4. âœ… ê¸°ë³¸ í—¬ìŠ¤ì²´í¬

### Phase 2 (ì•ˆì •ì„± ê°•í™”) - 2ì£¼
1. ğŸ“‹ ë©”ì‹œì§€ ì••ì¶•
2. ğŸ“‹ ìš°ì„ ìˆœìœ„ í
3. ğŸ“‹ ì—°ê²° í’ˆì§ˆ ëª¨ë‹ˆí„°ë§
4. ğŸ“‹ ê·¸ë ˆì´ìŠ¤í’€ ì…§ë‹¤ìš´

### Phase 3 (ê³ ê¸‰ ê¸°ëŠ¥) - 3ì£¼
1. ğŸ”„ íšŒë¡œ ì°¨ë‹¨ê¸° íŒ¨í„´
2. ğŸ”„ í† í° ê¸°ë°˜ ì¬ì¸ì¦
3. ğŸ”„ ìƒì„¸ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
4. ğŸ”„ ì—°ê²° ë§ˆì´ê·¸ë ˆì´ì…˜

### ì˜ˆìƒ íš¨ê³¼
- **ì•ˆì •ì„±**: ë„¤íŠ¸ì›Œí¬ ì¥ì•  ì‹œ ë³µêµ¬ ì‹œê°„ 50% ë‹¨ì¶•
- **ì„±ëŠ¥**: ë©”ì‹œì§€ ì••ì¶•ìœ¼ë¡œ ëŒ€ì—­í­ 30% ì ˆê°
- **ê´€ì°°ì„±**: ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ìœ¼ë¡œ ë¬¸ì œ ì¡°ê¸° ë°œê²¬
- **ë³´ì•ˆ**: ì•…ì˜ì  ì—°ê²° ì‹œë„ ìë™ ì°¨ë‹¨

## ì°¸ê³  ìë£Œ
- [TCP Socket Programming Best Practices](https://docs.python.org/3/howto/sockets.html)
- [Asyncio TCP Server Documentation](https://docs.python.org/3/library/asyncio-stream.html)
- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html)