# 오목 게임 설계 원칙 및 구조

## 1. 게임 세션 및 상태 관리
- **player1**: 게임을 오픈한 유저(항상 고정)
- **player2**: AI 또는 유저 대전 시 참여한 두 번째 유저(항상 고정)
- **돌 색깔**: player1/player2와 무관하게, 게임 진행 중 언제든 바뀔 수 있음(특히 swap 룰)
- **게임 상태**:  
  - 환경설정(파라미터/UX 선택)  
  - 오프닝(스왑 등)  
  - 본게임(턴제 진행)  
  - 종료(유효/무효)

## 2. 명령 파라미터 및 UX 선택
- `# 오목 시작 {명령 파라미터들}`  
  → 파라미터와 UX 선택(예: AI/유저 대전, 돌 색, 룰 등)을 모두 반영하여  
  → 세션에 **게임 설정**을 저장  
  → 이 설정은 게임 종료까지 유지

## 3. 게임 시작 전 단계
- 명령 파라미터 및 UX 선택(예: AI/유저 대전, 돌 색, 룰 등)
- AI/유저 대전 선택 메시지 → 응답(1/2) 대기
- 유저 대전 선택 시, 참여 안내 메시지 → `# 오목 참여`로 player2 등록

## 4. 게임 시작
- 오프닝(스왑 룰 등) 처리:  
  - 돌 색/턴/오프닝 진행상황 등은 세션에 저장  
  - 오프닝이 끝나면 본게임으로 진입
- 본게임:  
  - 돌 색에 따라 턴이 바뀌며,  
  - 각 턴마다 **move_timeout**이 등록됨  
  - 착수 함수는 한 곳에서 모든 분기(일반/스왑/AI/유저 등) 처리

## 5. 타임아웃 관리
- `start_timeout`: 게임 시작 전(설정/참여/오프닝 등) 대기 시간
- `move_timeout`: 본게임에서 각 턴별 착수 제한 시간  
  → **착수 함수에서만 등록/해제** (DRY)

## 6. 게임 종료
- **종료 함수는 반드시 하나**  
  - 유효 종료(승패/무승부/타임아웃 등)  
  - 무효 종료(명령/타임아웃/오류 등)  
  - 종료 사유/상황에 따라 메시지/DB 저장/통계 등 분기 처리

## 7. DRY 원칙
- 착수 함수, 종료 함수, 타임아웃 함수 등  
  → **핵심 로직은 반드시 한 곳에서만**  
  → 각 상황별 분기는 함수 내부에서 처리

---

## 추가로 고려해야 할 사항 (보완 제안)

1. **세션 일관성 및 동시성**
   - 여러 명령/이벤트가 동시에 들어올 때 세션 상태가 꼬이지 않도록  
     Lock/atomic update 등 고려 필요

2. **예외 상황 처리**
   - 잘못된 명령, 중복 참여, 중간에 유저 이탈 등  
     모든 예외 상황에 대한 안내 및 세션 정리

3. **상태 전이 명확화**
   - 각 단계(설정/오프닝/본게임/종료)별로  
     세션의 상태(state)를 명확히 관리  
   - 상태에 따라 허용되는 명령/이벤트만 처리

4. **DB/통계 연동**
   - 유효 종료 시 전적/통계 저장  
   - 무효 종료 시 저장하지 않음

5. **테스트/유지보수 용이성**
   - 각 함수는 단일 책임 원칙(SRP) 준수  
   - 유닛테스트/통합테스트가 용이하도록 설계

6. **확장성**
   - 룰/옵션/AI/UX 확장에 유연하도록  
     파라미터/상태/핸들러 구조 설계

---

## 요약

- **player1/player2는 고정, 돌 색은 언제든 바뀔 수 있음**
- **턴은 돌 색 기준, 착수/종료/타임아웃 함수는 반드시 DRY하게 한 곳에서만**
- **게임 상태(state)와 세션 일관성 관리가 핵심**
- **모든 분기/예외/확장에 유연하게 대응할 수 있도록 설계**





반드시 수정/리팩토링이 필요한 주요 포인트
1. 세션 및 상태 관리 일원화
player1/player2, 돌 색, 턴, 게임 상태(state) 등
→ OmokSession 등 세션 객체에 일관성 있게 저장/관리해야 함
현재는 일부 정보가 전역 dict, 일부는 파라미터, 일부는 임시 변수 등으로 분산되어 있음
→ 모든 상태를 세션 객체에 통합 필요
2. 착수/턴/타임아웃 함수 DRY화
착수 함수가 여러 군데(일반/AI/스왑 등) 분산되어 있으면
→ 하나의 함수에서 모든 분기(스왑/AI/유저/오프닝/본게임 등) 처리
move_timeout 등록/해제도 착수 함수 내부에서만 처리
3. 종료 함수 DRY화
게임 종료(승패/무효/타임아웃/명령 등)도
→ 하나의 함수에서 종료 사유별로 분기 처리
→ DB 저장/메시지 전송/세션 정리 등도 이 함수에서만
4. 상태 전이 및 예외 처리
세션의 상태(state)를 명확히 관리
→ 각 상태별로 허용되는 명령/이벤트만 처리
→ 예외 상황(중복 참여, 잘못된 명령 등)도 일관성 있게 처리
5. 파라미터/옵션/룰 관리
명령 파라미터, 룰, 옵션 등도
→ 세션에 통합 저장
→ 게임 종료까지 일관성 있게 사용
6. 확장성/테스트성
함수별 단일 책임 원칙(SRP) 준수
유닛테스트/통합테스트가 용이하도록 함수 분리 및 의존성 최소화
실제로 많이 바뀌는 부분 예시
착수 처리:
기존에는 AI/유저/스왑/일반 등 분기별로 함수가 나뉘어 있을 수 있음
→ 하나의 착수 함수로 통합, 내부에서 상황별 분기
타임아웃 처리:
여러 곳에서 타임아웃 등록/해제 코드가 중복
→ 착수 함수/종료 함수에서만 타임아웃 관리
종료 처리:
명령/타임아웃/승패 등 종료 상황별로 함수가 나뉘어 있을 수 있음
→ 하나의 종료 함수에서 종료 사유별 분기
세션/상태 관리:
여러 전역 변수/임시 변수/파라미터에 분산
→ OmokSession 등 세션 객체에 통합
결론
기존 코드가 하드코딩/분산/중복이 많다면, 대대적인 구조 리팩토링이 필요합니다.
하지만, 이 설계대로 리팩토링하면
유지보수성, 확장성, 테스트성, 코드 품질이 크게 향상됩니다.
추천
점진적 리팩토링:
한 번에 모든 코드를 바꾸기보다는
세션/상태 관리 일원화 → 착수/종료/타임아웃 DRY화 → 상태 전이/예외 처리 정비
순서로 단계별로 리팩토링하는 것이 현실적입니다.
추가로,
구체적으로 어떤 부분이 가장 부담스럽거나 궁금하신지
리팩토링 우선순위가 궁금하신지
알려주시면 더 맞춤형으로 안내드릴 수 있습니다!
